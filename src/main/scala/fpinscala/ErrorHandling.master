package fpinscala

import org.scalacheck._

// #example Option
trait Option[+A]
case class Some[+A](get: A) extends Option[A]
case object None extends Option[A]

suite Option {
header {
    
}
question flatMap
prompt
answer
hint

}

// #header
trait Option[+A] {

  // #question Option.map
  // #prompt 
  def map[B](f: A => B): Option[B] = 
    sys.error("todo")

    // #hint
    // Try pattern matching on `this`. 

    // #answer 
    this match { 
      case None => None
      case Some(a) => Some(f(a))
    }

    // #explanation
    // It's quite common to implement functions over ADTs by 
    // pattern matching and supplying a handler for each 
    // data constructor of the ADT.

  // #question Option.flatMap
  // #prompt 
  def flatMap[B](f: A => Option[B]): Option[B] =
    sys.error("todo")

    // #answer
    this map f getOrElse None

  // #question Option.getOrElse
  // #prompt
  def getOrElse[B>:A](default: => B): B =  
    sys.error("todo")

    // #hint
    // Try pattern matching on `this`.
    
    // #answer
    this match {
      case None => default
      case Some(b) => b
    }

  // #question Option.orElse
  // #prompt
  def orElse[B>:A](ob: => Option[B]): Option[B] =
    sys.error("todo")

    // #answer
    match { 
      case None => ob
      case _ => this
    }
    // #alternate
    this map (Some(_)) getOrElse ob

  // #question Option.orElse
  // #prompt
  def filter(f: A => Boolean): Option[A] =
    sys.error("todo")
// #footer
}
case class Some[+A](get: A) extends Option[A] 
case object None extends Option[Nothing]

trait ErrorHandling { 

  def average(xs: IndexedSeq[Double]): Option[Double] = 
    if (xs.isEmpty) None 
    else Some(xs.sum / xs.length)

  def 
}

